import numpy as np
from math import pi, cos, sin 
import sympy as sym
from sympy.matrices import Matrix 

def rotation_euler(euler_angles, translation):
        alpha, beta, gamma = euler_angles
        x, y, z = translation
        
        Rx =  np.array([[1,          0,           0],
                        [0, cos(alpha), -sin(alpha)],
                        [0, sin(alpha),  cos(alpha)]])
        
        Ry =  np.array([[cos(beta),  0, sin(beta)],
                        [0,          1,         0],
                        [-sin(beta), 0, cos(beta)]])
        
        Rz =  np.array([[cos(gamma), -sin(gamma), 0],
                        [sin(gamma),  cos(gamma), 0],
                        [         0,           0, 1]])
        
        R = Rx.dot(Ry)
        R = R.dot(Rz)
        T = np.column_stack((R, np.array([x, y, z])))
        T = np.row_stack((T, np.array([0, 0, 0, 1])))
        # Approximate small values to zero
        return np.where(np.abs(T) < 1e-6, 0, T)

# Calculation of symbolic task and Jacobian
def symbolic_task_middle(positions, orientations, symbols):
    # Approximate small values to zero
    positions = np.where(np.abs(positions) < 1e-6, 0, positions).astype(np.float64)
    orientations = np.where(np.abs(orientations) < 1e-6, 0, orientations).astype(np.float64)

    # Joint1 position
    p0 = positions[0]
    # DH parameters
    r1, r2, r3 = positions[1:, 0]
    d1, d2, d3 = positions[1:, 2]

    o0_1, o1_2, o2_3 = orientations

    TO1 = rotation_euler(o0_1, p0)
    TO2 = rotation_euler(o1_2, [0, 0, 0])
    TO3 = rotation_euler(o2_3, [0, 0, 0])

    j1, j2, j3 = symbols

    # Homogenous transformations from origin to tip according to standard DH convention

    TDH1 = Matrix([[sym.cos(j1), -sym.sin(j1), 0, r1*sym.cos(j1)], \
                   [sym.sin(j1),  sym.cos(j1), 0, r1*sym.sin(j1)], \
                   [0,                      0, 1,             d1], 
                   [0,                      0, 0,              1]])
    
    TDH2 = Matrix([[sym.cos(j2), -sym.sin(j2), 0, r2*sym.cos(j2)], \
                   [sym.sin(j2),  sym.cos(j2), 0, r2*sym.sin(j2)], \
                   [0,                      0, 1,             d2], 
                   [0,                      0, 0,              1]])
    
    TDH3 = Matrix([[sym.cos(j3), -sym.sin(j3), 0, r3*sym.cos(j3)], \
                   [sym.sin(j3),  sym.cos(j3), 0, r3*sym.sin(j3)], \
                   [0,                      0, 1,             d3], 
                   [0,                      0, 0,              1]])
    
    T = Matrix(TO1)*TDH1
    T = T*Matrix(TO2)
    T = sym.simplify(T*Matrix(TDH2))
    T = T*Matrix(TO3)
    T = T*Matrix(TDH3)

    # Cartesian task [x y z]
    pos = (Matrix(T[0:3,3], ndmin=2)).T
    
    # Task Jacobian: p_dot = Jp(q)q_dot
    Jp = Matrix([[sym.diff(pos, j1)], [sym.diff(pos, j2)], [sym.diff(pos, j3)]]).T
    
    return pos, Jp

def actuation_middle(dr, q, joint_limits):
    q1, q2, q3 = q

    # Proportional gain
    K = 1.0

    # Numerical actual position for computational semplicity
    p = np.array([[-0.442956659806621*(0.48060350967575*sin(q1) - 0.859314483013032*cos(q1))*sin(q2) + 0.00815819137786174*(0.48060350967575*sin(q1) - 0.859314483013032*cos(q1))*cos(q2) + 0.00815819137786174*(0.807491478621803*sin(q1) + 0.51144757237086*cos(q1))*sin(q2) + 0.442956659806621*(0.807491478621803*sin(q1) + 0.51144757237086*cos(q1))*cos(q2) + 0.360915620477857*(-0.979572981254007*(0.48060350967575*sin(q1) - 0.859314483013032*cos(q1))*sin(q2) - 0.0534626589360971*(0.48060350967575*sin(q1) - 0.859314483013032*cos(q1))*cos(q2) - 0.0534626589360971*(0.807491478621803*sin(q1) + 0.51144757237086*cos(q1))*sin(q2) + 0.979572981254007*(0.807491478621803*sin(q1) + 0.51144757237086*cos(q1))*cos(q2) + 0.0663012187732676*sin(q1) - 6.5265078774674e-15*cos(q1))*cos(q3) + 0.360915620477857*(-0.00636729563935741*(0.48060350967575*sin(q1) - 0.859314483013032*cos(q1))*sin(q2) - 0.955280265408194*(0.48060350967575*sin(q1) - 0.859314483013032*cos(q1))*cos(q2) - 0.955280265408194*(0.807491478621803*sin(q1) + 0.51144757237086*cos(q1))*sin(q2) + 0.00636729563935741*(0.807491478621803*sin(q1) + 0.51144757237086*cos(q1))*cos(q2) - 0.101112557520149*sin(q1) + 9.95323940307719e-15*cos(q1))*sin(q3) + 0.362669625031995*sin(q1) + 0.125001809394885*cos(q1) + 3.98684036355401e-6, 0.360915620477857*(-0.281873406187208*sin(q2) - 0.165231389380714*cos(q2) + 0.277804468609896)*sin(q3) + 0.360915620477857*(-0.18706499665854*sin(q2) + 0.278547327854434*cos(q2) - 0.182161101461861)*cos(q3) - 0.075086642699223*sin(q2) + 0.131613305005146*cos(q2) + 0.392159957909381, -0.00815819137786174*(0.51144757237086*sin(q1) - 0.807491478621803*cos(q1))*sin(q2) - 0.442956659806621*(0.51144757237086*sin(q1) - 0.807491478621803*cos(q1))*cos(q2) - 0.442956659806621*(0.859314483013032*sin(q1) + 0.48060350967575*cos(q1))*sin(q2) + 0.00815819137786174*(0.859314483013032*sin(q1) + 0.48060350967575*cos(q1))*cos(q2) + 0.360915620477857*(0.0534626589360971*(0.51144757237086*sin(q1) - 0.807491478621803*cos(q1))*sin(q2) - 0.979572981254007*(0.51144757237086*sin(q1) - 0.807491478621803*cos(q1))*cos(q2) - 0.979572981254007*(0.859314483013032*sin(q1) + 0.48060350967575*cos(q1))*sin(q2) - 0.0534626589360971*(0.859314483013032*sin(q1) + 0.48060350967575*cos(q1))*cos(q2) + 6.52650787746751e-15*sin(q1) + 0.0663012187732676*cos(q1))*cos(q3) + 0.360915620477857*(0.955280265408194*(0.51144757237086*sin(q1) - 0.807491478621803*cos(q1))*sin(q2) - 0.00636729563935741*(0.51144757237086*sin(q1) - 0.807491478621803*cos(q1))*cos(q2) - 0.00636729563935741*(0.859314483013032*sin(q1) + 0.48060350967575*cos(q1))*sin(q2) - 0.955280265408194*(0.859314483013032*sin(q1) + 0.48060350967575*cos(q1))*cos(q2) - 9.95323940307736e-15*sin(q1) - 0.101112557520149*cos(q1))*sin(q3) - 0.125001809394885*sin(q1) + 0.362669625031995*cos(q1) + 1.95493662373939]]).T

    # Distance of tip from origin  
    d = np.linalg.norm(p)

    # Numerical Jacobian for computational semplicity
    Jp = [[0.00815819137786174*(-0.51144757237086*sin(q1) + 0.807491478621803*cos(q1))*sin(q2) + 0.442956659806621*(-0.51144757237086*sin(q1) + 0.807491478621803*cos(q1))*cos(q2) - 0.442956659806621*(0.859314483013032*sin(q1) + 0.48060350967575*cos(q1))*sin(q2) + 0.00815819137786174*(0.859314483013032*sin(q1) + 0.48060350967575*cos(q1))*cos(q2) + 0.360915620477857*(-0.955280265408194*(-0.51144757237086*sin(q1) + 0.807491478621803*cos(q1))*sin(q2) + 0.00636729563935741*(-0.51144757237086*sin(q1) + 0.807491478621803*cos(q1))*cos(q2) - 0.00636729563935741*(0.859314483013032*sin(q1) + 0.48060350967575*cos(q1))*sin(q2) - 0.955280265408194*(0.859314483013032*sin(q1) + 0.48060350967575*cos(q1))*cos(q2) - 9.95323940307719e-15*sin(q1) - 0.101112557520149*cos(q1))*sin(q3) + 0.360915620477857*(-0.0534626589360971*(-0.51144757237086*sin(q1) + 0.807491478621803*cos(q1))*sin(q2) + 0.979572981254007*(-0.51144757237086*sin(q1) + 0.807491478621803*cos(q1))*cos(q2) - 0.979572981254007*(0.859314483013032*sin(q1) + 0.48060350967575*cos(q1))*sin(q2) - 0.0534626589360971*(0.859314483013032*sin(q1) + 0.48060350967575*cos(q1))*cos(q2) + 6.5265078774674e-15*sin(q1) + 0.0663012187732676*cos(q1))*cos(q3) - 0.125001809394885*sin(q1) + 0.362669625031995*cos(q1), -0.00815819137786174*(0.48060350967575*sin(q1) - 0.859314483013032*cos(q1))*sin(q2) - 0.442956659806621*(0.48060350967575*sin(q1) - 0.859314483013032*cos(q1))*cos(q2) - 0.442956659806621*(0.807491478621803*sin(q1) + 0.51144757237086*cos(q1))*sin(q2) + 0.00815819137786174*(0.807491478621803*sin(q1) + 0.51144757237086*cos(q1))*cos(q2) + 0.360915620477857*(0.0534626589360971*(0.48060350967575*sin(q1) - 0.859314483013032*cos(q1))*sin(q2) - 0.979572981254007*(0.48060350967575*sin(q1) - 0.859314483013032*cos(q1))*cos(q2) - 0.979572981254007*(0.807491478621803*sin(q1) + 0.51144757237086*cos(q1))*sin(q2) - 0.0534626589360971*(0.807491478621803*sin(q1) + 0.51144757237086*cos(q1))*cos(q2))*cos(q3) + 0.360915620477857*(0.955280265408194*(0.48060350967575*sin(q1) - 0.859314483013032*cos(q1))*sin(q2) - 0.00636729563935741*(0.48060350967575*sin(q1) - 0.859314483013032*cos(q1))*cos(q2) - 0.00636729563935741*(0.807491478621803*sin(q1) + 0.51144757237086*cos(q1))*sin(q2) - 0.955280265408194*(0.807491478621803*sin(q1) + 0.51144757237086*cos(q1))*cos(q2))*sin(q3), -0.360915620477857*(-0.979572981254007*(0.48060350967575*sin(q1) - 0.859314483013032*cos(q1))*sin(q2) - 0.0534626589360971*(0.48060350967575*sin(q1) - 0.859314483013032*cos(q1))*cos(q2) - 0.0534626589360971*(0.807491478621803*sin(q1) + 0.51144757237086*cos(q1))*sin(q2) + 0.979572981254007*(0.807491478621803*sin(q1) + 0.51144757237086*cos(q1))*cos(q2) + 0.0663012187732676*sin(q1) - 6.5265078774674e-15*cos(q1))*sin(q3) + 0.360915620477857*(-0.00636729563935741*(0.48060350967575*sin(q1) - 0.859314483013032*cos(q1))*sin(q2) - 0.955280265408194*(0.48060350967575*sin(q1) - 0.859314483013032*cos(q1))*cos(q2) - 0.955280265408194*(0.807491478621803*sin(q1) + 0.51144757237086*cos(q1))*sin(q2) + 0.00636729563935741*(0.807491478621803*sin(q1) + 0.51144757237086*cos(q1))*cos(q2) - 0.101112557520149*sin(q1) + 9.95323940307719e-15*cos(q1))*cos(q3)], [0, 0.360915620477857*(-0.278547327854434*sin(q2) - 0.18706499665854*cos(q2))*cos(q3) + 0.360915620477857*(0.165231389380714*sin(q2) - 0.281873406187208*cos(q2))*sin(q3) - 0.131613305005146*sin(q2) - 0.075086642699223*cos(q2), 0.360915620477857*(-0.281873406187208*sin(q2) - 0.165231389380714*cos(q2) + 0.277804468609896)*cos(q3) - 0.360915620477857*(-0.18706499665854*sin(q2) + 0.278547327854434*cos(q2) - 0.182161101461861)*sin(q3)], [-0.442956659806621*(-0.48060350967575*sin(q1) + 0.859314483013032*cos(q1))*sin(q2) + 0.00815819137786174*(-0.48060350967575*sin(q1) + 0.859314483013032*cos(q1))*cos(q2) - 0.00815819137786174*(0.807491478621803*sin(q1) + 0.51144757237086*cos(q1))*sin(q2) - 0.442956659806621*(0.807491478621803*sin(q1) + 0.51144757237086*cos(q1))*cos(q2) + 0.360915620477857*(-0.979572981254007*(-0.48060350967575*sin(q1) + 0.859314483013032*cos(q1))*sin(q2) - 0.0534626589360971*(-0.48060350967575*sin(q1) + 0.859314483013032*cos(q1))*cos(q2) + 0.0534626589360971*(0.807491478621803*sin(q1) + 0.51144757237086*cos(q1))*sin(q2) - 0.979572981254007*(0.807491478621803*sin(q1) + 0.51144757237086*cos(q1))*cos(q2) - 0.0663012187732676*sin(q1) + 6.52650787746751e-15*cos(q1))*cos(q3) + 0.360915620477857*(-0.00636729563935741*(-0.48060350967575*sin(q1) + 0.859314483013032*cos(q1))*sin(q2) - 0.955280265408194*(-0.48060350967575*sin(q1) + 0.859314483013032*cos(q1))*cos(q2) + 0.955280265408194*(0.807491478621803*sin(q1) + 0.51144757237086*cos(q1))*sin(q2) - 0.00636729563935741*(0.807491478621803*sin(q1) + 0.51144757237086*cos(q1))*cos(q2) + 0.101112557520149*sin(q1) - 9.95323940307736e-15*cos(q1))*sin(q3) - 0.362669625031995*sin(q1) - 0.125001809394885*cos(q1), 0.442956659806621*(0.51144757237086*sin(q1) - 0.807491478621803*cos(q1))*sin(q2) - 0.00815819137786174*(0.51144757237086*sin(q1) - 0.807491478621803*cos(q1))*cos(q2) - 0.00815819137786174*(0.859314483013032*sin(q1) + 0.48060350967575*cos(q1))*sin(q2) - 0.442956659806621*(0.859314483013032*sin(q1) + 0.48060350967575*cos(q1))*cos(q2) + 0.360915620477857*(0.00636729563935741*(0.51144757237086*sin(q1) - 0.807491478621803*cos(q1))*sin(q2) + 0.955280265408194*(0.51144757237086*sin(q1) - 0.807491478621803*cos(q1))*cos(q2) + 0.955280265408194*(0.859314483013032*sin(q1) + 0.48060350967575*cos(q1))*sin(q2) - 0.00636729563935741*(0.859314483013032*sin(q1) + 0.48060350967575*cos(q1))*cos(q2))*sin(q3) + 0.360915620477857*(0.979572981254007*(0.51144757237086*sin(q1) - 0.807491478621803*cos(q1))*sin(q2) + 0.0534626589360971*(0.51144757237086*sin(q1) - 0.807491478621803*cos(q1))*cos(q2) + 0.0534626589360971*(0.859314483013032*sin(q1) + 0.48060350967575*cos(q1))*sin(q2) - 0.979572981254007*(0.859314483013032*sin(q1) + 0.48060350967575*cos(q1))*cos(q2))*cos(q3), -0.360915620477857*(0.0534626589360971*(0.51144757237086*sin(q1) - 0.807491478621803*cos(q1))*sin(q2) - 0.979572981254007*(0.51144757237086*sin(q1) - 0.807491478621803*cos(q1))*cos(q2) - 0.979572981254007*(0.859314483013032*sin(q1) + 0.48060350967575*cos(q1))*sin(q2) - 0.0534626589360971*(0.859314483013032*sin(q1) + 0.48060350967575*cos(q1))*cos(q2) + 6.52650787746751e-15*sin(q1) + 0.0663012187732676*cos(q1))*sin(q3) + 0.360915620477857*(0.955280265408194*(0.51144757237086*sin(q1) - 0.807491478621803*cos(q1))*sin(q2) - 0.00636729563935741*(0.51144757237086*sin(q1) - 0.807491478621803*cos(q1))*cos(q2) - 0.00636729563935741*(0.859314483013032*sin(q1) + 0.48060350967575*cos(q1))*sin(q2) - 0.955280265408194*(0.859314483013032*sin(q1) + 0.48060350967575*cos(q1))*cos(q2) - 9.95323940307736e-15*sin(q1) - 0.101112557520149*cos(q1))*cos(q3)]]
    
    # Extended jacobian for distance: d_dot = Jd(q)q_dot
    Jd = 1/d * p.T.dot(Jp)
    
    # Jacobian Damped Least Squared (DLS)
    Jd_trans = Jd.transpose()
    detJ = np.float64(Jd.dot(Jd_trans))
    if detJ <= 1e-1:
        mu = (detJ + 1.0)/5
    else:
        mu = 0
    Jinv = Jd_trans.dot(1/(detJ + mu**2))

    # Vector for null space control
    w = np.array([((joint_limits[0]-pi/4)/2 - q1)/(joint_limits[0] + pi/4),\
                  ((joint_limits[1]/2) - q2)/(joint_limits[1]),\
                      (joint_limits[2]/2 - q3)/(joint_limits[2])])
    u_vinc = (np.eye(3) - Jinv.dot(Jd))*w.transpose()

    # Compute the joint velocities
    qdot = Jinv.dot(K*(dr - d)) + u_vinc

    return qdot, d